
<div class="commands">

    <form onsubmit="return false">

        <label data-for="name">
            name <input type="text" value="" placeholder="name for object" />
        </label>
        <label data-param="link">
            Link to <input type="text" value="" placeholder="name of panorama" />
        </label>
        <label data-for="hoverText">
            Hover Text <textarea placeholder=" ... "></textarea>
        </label>
        <label data-for="image">
            Image <input type="text" value="" placeholder="url image" />
        </label>


    </form>
    <script>
        
    </script>

</div>



<script>
// Edit mode plugin        
        
// v : Viewer
const applyEditMode = function(posterlens) {

// INIT propierties:
const v = posterlens.viewer;
// v.editObj = null;
// const world = v.panorama.getObjectByName('invisibleWorld'); // to calculate the Vector 3 pos
// const mouse2D = new THREE.Vector2();
const self = this; 

// INIT method
// v.editControls = new DragControls( posterlens.getObjects(), v.camera, v.renderer.domElement );
// v.editControls.enabled = false;
v.editMode = true;
if (v.editMode && typeof stopAllAnimations !== 'undefined') stopAllAnimations(v);
v.editObj = null;
const SCALE_FACTOR = 1.1;
const ROTATE_DEG = 0.1; // radians. 3.1416 is 180 deg.


// Widgets
// Buttn to enable/disable Edit Mode: NOT IN USE
v.appendControlItem({
    style: {
        backgroundImage: 'url(https://images-na.ssl-images-amazon.com/images/I/91ovrqFkzkL._RI_SX200_.jpg)',
        float: 'left'
    },    
    onTap: () => { 
        v.editMode = !v.editMode;
        if (v.editMode && typeof stopAllAnimations !== 'undefined') stopAllAnimations(v);  
        posterlens.exportOptions('input'); // console the new
    },
    group: 'editmode'
});
// Create poster
v.appendControlItem({
    style: {
        backgroundImage: 'url(https://images-na.ssl-images-amazon.com/images/I/91ovrqFkzkL._RI_SX200_.jpg)',
        float: 'left'
    },    
    onTap: () => { 
        let pos = v.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(300);
        let object = pl.createPoster3D( v.panorama, 'https://images-na.ssl-images-amazon.com/images/I/91ovrqFkzkL._RI_SX200_.jpg', Object.values(pos), {} );
    },
    group: 'editmode'
});

// Events

// getting position on the click. Interects innerworld
v.panorama.addEventListener('click', (event) => {
    console.info( self.getMouse3Dposition(event), window.obj.name );
});

// start dragging object
v.renderer.domElement.addEventListener('mousedown', (event) => { 
    const pano = v.panorama;
    // window.obj = event.intersects[0]? event.intersects[0].object : null ;
    const intersects = v.raycaster.intersectObject( v.panorama, true );
    window.obj = intersects[0]? intersects[0].object : null ;
    if (!window.obj.type.startsWith('pl_')) return;

    stopAllAnimations(v);
    console.log('CLicked', window.obj.name);
    // // if is 1nd click to start dragging obj
    if ( v.editMode && intersects.length > 0 ) { 
        v.OrbitControls.enabled = false;
        const point = intersects[ 0 ].point.clone(); // this works
        v.editObj = window.obj;
        v.editObj.originalPos = v.editObj.position;                
        v.editObj.removeEventListener('click', 'posterlens-handler', false); // DOESNT WORK! the event is backed up safe in obj._click
        }
} );
v.renderer.domElement.addEventListener('mouseup', (event) => { 
    v.OrbitControls.enabled = true;
    if (!v.editObj) return;
    console.log('New pOSITION for '+v.editObj.name+' : ', v.editObj.position);
    setTimeout( () => v.editObj = false, 100);
});
v.renderer.domElement.addEventListener('mousemove', (event) => {
    if (!v.editObj) return;
    const newPos = self.getMouse3Dposition(event);
    // console.log(v.editObj.name + ' : ', newPos); 
    posterlens.setObjectPos(v.editObj, newPos);
});
document.addEventListener('keydown', (event) => {
    if (!v.editMode || !window.obj) return;
    switch (event.key) {
        case '+': window.obj.scale.set( window.obj.scale.x * SCALE_FACTOR, window.obj.scale.y * SCALE_FACTOR, window.obj.scale.z * SCALE_FACTOR );      break;
        case '-': window.obj.scale.set( window.obj.scale.x / SCALE_FACTOR, window.obj.scale.y / SCALE_FACTOR, window.obj.scale.z / SCALE_FACTOR );      break;
        case 'r': window.obj.rotation.z += ROTATE_DEG;  break;
        case 't': window.obj.rotation.z -= ROTATE_DEG;  break;
        case 'f': window.obj.rotation.y += ROTATE_DEG;  break;
        case 'g': window.obj.rotation.y -= ROTATE_DEG;  break;
        default:
            break;
    }
});
    
// helpers
this.getMouse3Dposition = function(event) {
    const intersects = v.raycaster.intersectObject( v.panorama, true );
    if ( intersects.length <= 0 ) return;
    let i = 0;
    while ( i < intersects.length ) {
        if (intersects[i].object.name === 'invisibleWorld') {
            const point = intersects[i].point.clone();
            const world = v.panorama.getWorldPosition( new THREE.Vector3() );
            point.sub( world );
            return [ point.x.toFixed(2)/2, point.y.toFixed(2)/2, point.z.toFixed(2)/2 ];
        }
        i++;
    }
    
}


posterlens.exportOptions = function(mode='console') {
    const originalOptions = posterlens.o;
    posterlens.o.worlds.forEach( (panoOptions, i) => {
        const panorama = v.scene.children[i];
        //if (panorama === v.panorama ) {
            posterlens.o.worlds[i].hotspots.forEach( (ht, index) => {
                                
                const object = pl.getObjectByName(ht.name, panorama);
                if (!object) console.error('not found object num'+index +' '+ ht.name + ' in panorama '+panorama.name);
                
                posterlens.o.worlds[i].hotspots[index].pos = [ ... Object.values(object.position) ] ;
                posterlens.o.worlds[i].hotspots[index].rot =  object.rotation.z;
                posterlens.o.worlds[i].hotspots[index].scale = object.scale.y;
            });
            // }
    });
    
    const exportStr = 'var data = ' + JSON.stringify(posterlens.o, false, 2); // .split('\n').map( line => line.replace('"', '').replace('"', '') ).join('\n')
    if (mode === 'console')
        console.log(exportStr);
    else {
        var textA = document.createElement( 'textarea' );
        textA.textContent = exportStr;
        textA.style.width = '100%'
        textA.style.height= '500px';
        modal = new posterlens.Modal('Export JSON', textA);
    }

}


const updateObjectFromForm = function() {
            
}    

const updateFormFromObject = function() {
            
}    



return self;
}
            
        </script>
    